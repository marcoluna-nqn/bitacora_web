import 'package:file_saver/file_saver.dart';
import 'package:excel/excel.dart' as xcel;
import 'dart:typed_data';
// lib/main.dart
// Bitácora Web — Grilla editable con autosave, backup/import JSON y export XLSX.
// Encabezados editables (vacíos por defecto). Navegación con flechas/Tab/Enter.
// Atajos: Ctrl+N (fila), Ctrl+E (XLSX), Ctrl+B (backup), Ctrl+U (import), Ctrl+L (limpiar), Ctrl+D (borrar fila).

import 'dart:async' show Timer;
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:bitacora_web/models/table_state.dart';

import 'package:bitacora_web/services/local_store.dart';
void main() => runApp(const MyApp());

// -------------------- APP y tema --------------------
class MyApp extends StatefulWidget {
  const MyApp({super.key});
  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  bool _light = true;

  ThemeData _buildTheme(bool light) {
    const blue = Color(0xFF0A84FF);
    final scheme = ColorScheme.fromSeed(
      seedColor: blue,
      brightness: light ? Brightness.light : Brightness.dark,
    );
    final scaffold = light ? const Color(0xFFF2F2F7) : const Color(0xFF0B1220);
    final card = light ? Colors.white : const Color(0xFF0E1624);

    return ThemeData(
      useMaterial3: true,
      colorScheme: scheme,
      scaffoldBackgroundColor: scaffold,
      cardColor: card,
      visualDensity: VisualDensity.compact,
      fontFamilyFallback: const ['SF Pro Text','Inter','Roboto','Segoe UI','Helvetica','Arial'],
      appBarTheme: AppBarTheme(
        backgroundColor: light ? Colors.white : const Color(0xFF0B1220),
        surfaceTintColor: Colors.transparent,
        elevation: 0,
        titleTextStyle: TextStyle(
          color: light ? Colors.black : Colors.white,
          fontWeight: FontWeight.w700,
          fontSize: 16,
        ),
        iconTheme: IconThemeData(color: light ? Colors.black87 : Colors.white),
      ),
      dividerColor: light ? const Color(0xFFE5E5EA) : const Color(0xFF243043),
      inputDecorationTheme: InputDecorationTheme(
        isDense: true,
        contentPadding: const EdgeInsets.symmetric(horizontal: 10, vertical: 8),
        border: OutlineInputBorder(borderRadius: BorderRadius.circular(10)),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(10),
          borderSide: const BorderSide(color: blue, width: 1.4),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Bitácora Web',
      debugShowCheckedModeBanner: false,
      theme: _buildTheme(true),
      darkTheme: _buildTheme(false),
      themeMode: _light ? ThemeMode.light : ThemeMode.dark,
      home: Home(isLight: _light, onToggleTheme: () => setState(() => _light = !_light)),
    );
  }
}

// -------------------- Modelo --------------------
class TableController {
  static const int defaultCols = 5;

  TableController() {
    final loaded = LocalStore.load();
    if (loaded != null && loaded.headers.isNotEmpty) {
      headers = List<String>.from(loaded.headers);
      rows = loaded.rows.map((r) => _padRow(r)).toList(growable: true);
    } else {
      headers = List<String>.filled(defaultCols, ''); // VACÍOS por defecto
      rows = List<List<String>>.generate(3, (_) => List<String>.filled(headers.length, ''));
    }
  }

  late List<String> headers;
  late List<List<String>> rows;

  final Debouncer _debounce = Debouncer(const Duration(milliseconds: 300));
  TableState toState() => TableState(headers: headers, rows: rows, savedAt: DateTime.now());
  void saveDebounced() => _debounce(() => LocalStore.save(toState()));

  void addRow() {
    rows.add(List<String>.filled(headers.length, ''));
    saveDebounced();
  }

  void removeRow(int index) {
    if (rows.isEmpty) return;
    final i = index.clamp(0, rows.length - 1);
    rows.removeAt(i);
    if (rows.isEmpty) addRow();
    saveDebounced();
  }

  void clearAll() {
    rows
      ..clear()
      ..addAll(List<List<String>>.generate(3, (_) => List<String>.filled(headers.length, '')));
    saveDebounced();
  }

  void setHeader(int index, String text) {
    if (index < 0 || index >= headers.length) return;
    headers[index] = text;
    saveDebounced();
  }

  void setCell(int r, int c, String v) {
    if (r < 0 || r >= rows.length) return;
    if (c < 0 || c >= headers.length) return;
    final row = rows[r];
    if (row.length != headers.length) rows[r] = _padRow(row);
    rows[r][c] = v;
    saveDebounced();
  }

  String getCell(int r, int c) {
    if (r < 0 || r >= rows.length) return '';
    if (c < 0 || c >= headers.length) return '';
    final row = rows[r];
    if (c >= row.length) return '';
    return row[c];
  }

  List<String> _padRow(List<String> r) {
    final out = List<String>.from(r);
    if (out.length < headers.length) {
      out.addAll(List<String>.filled(headers.length - out.length, ''));
    } else if (out.length > headers.length) {
      out.removeRange(headers.length, out.length);
    }
    return out;
  }
}

// -------------------- Grilla --------------------
class Home extends StatefulWidget {
  const Home({super.key, required this.isLight, required this.onToggleTheme});
  final bool isLight;
  final VoidCallback onToggleTheme;

  @override
  State<Home> createState() => _HomeState();
}

class _HomeState extends State<Home> {
  late final TableController ctrl;

  // Celdas
  final Map<String, TextEditingController> _ctls = {};
  final Map<String, FocusNode> _foci = {};

  // Encabezados
  final List<TextEditingController> _hdrCtls = [];
  final List<FocusNode> _hdrFoci = [];

  bool zebra = true;
  bool showGridLines = true;

  int _focusR = -1;
  int _focusC = -1;

  static const double indexColW = 56;
  static const double colW = 180;
  static const double rowH = 38;
  static const double hdrH = 42;
  double get _tableW => indexColW + ctrl.headers.length * colW;

  @override
  void initState() {
    super.initState();
    ctrl = TableController();
    _syncFromModel();
    _ensureHeaderControllers();
  }

  @override
  void dispose() {
    for (final c in _ctls.values) c.dispose();
    for (final f in _foci.values) f.dispose();
    for (final c in _hdrCtls) c.dispose();
    for (final f in _hdrFoci) f.dispose();
    super.dispose();
  }

  String _k(int r, int c) => '$r:$c';

  void _syncFromModel() {
    for (int r = 0; r < ctrl.rows.length; r++) {
      for (int c = 0; c < ctrl.headers.length; c++) {
        final key = _k(r, c);
        final text = ctrl.getCell(r, c);
        if (_ctls.containsKey(key)) {
          final ctl = _ctls[key]!;
          if (ctl.text != text) ctl.text = text;
        } else {
          final ctl = TextEditingController(text: text);
          ctl.addListener(() => ctrl.setCell(r, c, ctl.text));
          _ctls[key] = ctl;
        }
        _foci.putIfAbsent(key, () => FocusNode());
      }
    }
  }

  void _ensureHeaderControllers() {
    for (int i = 0; i < ctrl.headers.length; i++) {
      if (i >= _hdrCtls.length) {
        final c = TextEditingController(text: ctrl.headers[i]);
        c.addListener(() => ctrl.setHeader(i, c.text));
        _hdrCtls.add(c);
        _hdrFoci.add(FocusNode());
      } else if (_hdrCtls[i].text != ctrl.headers[i]) {
        _hdrCtls[i].text = ctrl.headers[i];
      }
    }
  }

  void _rebuildAllControllers() {
    for (final c in _ctls.values) c.dispose();
    for (final f in _foci.values) f.dispose();
    _ctls.clear();
    _foci.clear();
    _syncFromModel();
    _ensureHeaderControllers();
    setState(() {});
  }

  void _ensureRowOnEnter(int r) {
    if (r == ctrl.rows.length - 1) {
      final anyFilled = ctrl.rows[r].any((v) => v.trim().isNotEmpty);
      if (anyFilled) {
        ctrl.addRow();
        _syncFromModel();
        setState(() {});
      }
    }
  }

  bool _shiftDown() {
    final keys = HardwareKeyboard.instance.logicalKeysPressed;
    return keys.contains(LogicalKeyboardKey.shiftLeft) ||
        keys.contains(LogicalKeyboardKey.shiftRight);
  }

  void _moveFocus(int r, int c) {
    _focusR = r.clamp(0, ctrl.rows.length - 1);
    _focusC = c.clamp(0, ctrl.headers.length - 1);
    final nextKey = _k(_focusR, _focusC);
    Future.microtask(() => _foci[nextKey]?.requestFocus());
  }

  bool _isNumericCol(int c) {
    final h = ctrl.headers[c].toLowerCase();
    if (h.trim().isEmpty) return c == 2 || c == 3;
    return h.contains('ω') || h.contains('ohm') || h.contains('@1m') || h.contains('@3m');
  }

  KeyEventResult _handleKey(int r, int c, KeyEvent e) {
    if (e is! KeyDownEvent) return KeyEventResult.ignored;

    if (e.logicalKey == LogicalKeyboardKey.enter) {
      _ensureRowOnEnter(r);
      _moveFocus(r + 1, c);
      return KeyEventResult.handled;
    }
    if (e.logicalKey == LogicalKeyboardKey.tab) {
      final left = _shiftDown();
      _moveFocus(r, c + (left ? -1 : 1));
      return KeyEventResult.handled;
    }
    if (e.logicalKey == LogicalKeyboardKey.arrowDown) {
      _ensureRowOnEnter(r);
      _moveFocus(r + 1, c);
      return KeyEventResult.handled;
    }
    if (e.logicalKey == LogicalKeyboardKey.arrowUp) {
      _moveFocus(r - 1, c);
      return KeyEventResult.handled;
    }
    if (e.logicalKey == LogicalKeyboardKey.arrowRight) {
      _moveFocus(r, c + 1);
      return KeyEventResult.handled;
    }
    if (e.logicalKey == LogicalKeyboardKey.arrowLeft) {
      _moveFocus(r, c - 1);
      return KeyEventResult.handled;
    }
    return KeyEventResult.ignored;
  }

  // ---------- Celdas ----------
  Widget _buildHeaderTextField(int c) {
    final hintColor = Theme.of(context).textTheme.titleMedium?.color?.withOpacity(0.55);
    return Container(
      height: hdrH,
      alignment: Alignment.centerLeft,
      padding: const EdgeInsets.symmetric(horizontal: 12),
      decoration: BoxDecoration(
        color: Theme.of(context).brightness == Brightness.light
            ? const Color(0xFFF9F9FB) : const Color(0xFF111827),
        border: showGridLines
            ? Border(
          bottom: BorderSide(color: Theme.of(context).dividerColor),
          right: BorderSide(color: Theme.of(context).dividerColor),
        )
            : null,
      ),
      child: TextField(
        controller: _hdrCtls[c],
        focusNode: _hdrFoci[c],
        maxLines: 1,
        textInputAction: TextInputAction.next,
        decoration: InputDecoration(
          isDense: true,
          border: InputBorder.none,
          hintText: 'Col ${c + 1}',
          hintStyle: TextStyle(fontWeight: FontWeight.w600, color: hintColor),
        ),
        style: const TextStyle(fontWeight: FontWeight.w700),
        onSubmitted: (_) => _moveFocus(0, c),
      ),
    );
  }

  Widget _buildIndexCell(int r, {bool header = false}) {
    final bg = zebra && !header && r.isEven ? const Color(0x0C000000) : Colors.transparent;
    return Container(
      height: header ? hdrH : rowH,
      width: indexColW,
      alignment: Alignment.center,
      decoration: BoxDecoration(
        color: bg,
        border: showGridLines
            ? Border(
          bottom: BorderSide(color: Theme.of(context).dividerColor),
          right: BorderSide(color: Theme.of(context).dividerColor),
        )
            : null,
      ),
      child: Text(header ? '#' : '${r + 1}', style: const TextStyle(fontSize: 13.5, fontWeight: FontWeight.w700)),
    );
  }

  Widget _buildCell(int r, int c) {
    final key = _k(r, c);
    final ctl = _ctls[key]!;
    final node = _foci[key]!;
    final bg = zebra && r.isEven ? const Color(0x0C000000) : Colors.transparent;

    final inputFmt = _isNumericCol(c)
        ? <TextInputFormatter>[FilteringTextInputFormatter.allow(RegExp(r'[0-9.,-]'))]
        : const <TextInputFormatter>[];

    return Container(
      height: rowH,
      width: colW,
      alignment: Alignment.centerLeft,
      decoration: BoxDecoration(
        color: bg,
        border: showGridLines
            ? Border(
          bottom: BorderSide(color: Theme.of(context).dividerColor),
          right: BorderSide(color: Theme.of(context).dividerColor),
        )
            : null,
      ),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 8),
        child: Focus(
          focusNode: node,
          onFocusChange: (has) {
            if (has) { _focusR = r; _focusC = c; }
          },
          onKeyEvent: (node, e) => _handleKey(r, c, e),
          child: TextField(
            controller: ctl,
            maxLines: 1,
            textInputAction: TextInputAction.done,
            onTap: () { _focusR = r; _focusC = c; },
            onSubmitted: (_) { _ensureRowOnEnter(r); _moveFocus(r + 1, c); },
            inputFormatters: inputFmt,
            decoration: const InputDecoration(isDense: true, border: InputBorder.none),
            style: const TextStyle(fontSize: 13.5),
            cursorWidth: 1.2,
          ),
        ),
      ),
    );
  }

        Widget _grid() {
    final light = Theme.of(context).brightness == Brightness.light;
    final tableW = indexColW + ctrl.headers.length * colW;

    return DecoratedBox(
      decoration: BoxDecoration(
        color: Theme.of(context).cardColor,
        borderRadius: BorderRadius.circular(14),
        border: Border.all(color: Theme.of(context).dividerColor.withOpacity(0.8)),
        boxShadow: [if (light) const BoxShadow(blurRadius: 20, offset: Offset(0, 10), color: Color(0x15000000))],
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(14),
        child: SingleChildScrollView(
          scrollDirection: Axis.horizontal,
          child: SizedBox(
            width: tableW,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    _buildIndexCell(0, header: true),
                    for (int c = 0; c < ctrl.headers.length; c++)
                      SizedBox(width: colW, child: _buildHeaderTextField(c)),
                  ],
                ),
                const Divider(height: 0, thickness: 0),
                SizedBox(
                  height: 420,
                  child: ListView.builder(
                    padding: EdgeInsets.zero,
                    itemExtent: rowH,
                    itemCount: ctrl.rows.length,
                    physics: const ClampingScrollPhysics(),
                    shrinkWrap: true,
                    primary: false,
                    itemBuilder: (context, r) {
                      return Row(
                        children: [
                          _buildIndexCell(r),
                          for (int c = 0; c < ctrl.headers.length; c++) _buildCell(r, c),
                        ],
                      );
                    },
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
  Future<void> _backupDownload() async => LocalStore.downloadBackup(ctrl.toState());

  Future<void> _backupImport() async {
    final ts = await LocalStore.importBackup();
    if (ts == null) return;
    ctrl.headers = List<String>.from(ts.headers);
    ctrl.rows = ts.rows.map((r) => List<String>.from(r)).toList(growable: true);
    _rebuildAllControllers();
  }

  @override
  Widget build(BuildContext context) {
    return Shortcuts(
      shortcuts: <LogicalKeySet, Intent>{
        LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyN): const _AddRowIntent(),
        LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyE): const _ExportIntent(),
        LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyB): const _BackupIntent(),
        LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyU): const _ImportIntent(),
        LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyL): const _ClearIntent(),
        LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyD): const _DeleteRowIntent(),
      },
      child: Actions(
        actions: <Type, Action<Intent>>{
          _AddRowIntent: CallbackAction<_AddRowIntent>(onInvoke: (intent) { ctrl.addRow(); _syncFromModel(); setState(() {}); return null; }),
          _ExportIntent: CallbackAction<_ExportIntent>(onInvoke: (intent) { _exportXlsxImpl(ctrl.headers, ctrl.rows); return null; }),
          _BackupIntent: CallbackAction<_BackupIntent>(onInvoke: (intent) { _backupDownload(); return null; }),
          _ImportIntent: CallbackAction<_ImportIntent>(onInvoke: (intent) async { await _backupImport(); return null; }),
          _ClearIntent: CallbackAction<_ClearIntent>(onInvoke: (intent) { ctrl.clearAll(); _rebuildAllControllers(); return null; }),
          _DeleteRowIntent: CallbackAction<_DeleteRowIntent>(onInvoke: (intent) {
            if (_focusR >= 0) {
              ctrl.removeRow(_focusR);
              _rebuildAllControllers();
              final r = (_focusR - 1).clamp(0, ctrl.rows.length - 1);
              _moveFocus(r, _focusC < 0 ? 0 : _focusC);
            }
            return null;
          }),
        },
        child: Scaffold(
          appBar: AppBar(
            title: const Text('Bitácora Web'),
            actions: [
              IconButton(
                tooltip: 'Preferencias',
                onPressed: () {
                  showModalBottomSheet(
                    context: context,
                    useSafeArea: true,
                    showDragHandle: true,
                    builder: (ctx) {
                      return Padding(
                        padding: const EdgeInsets.fromLTRB(16, 8, 16, 24),
                        child: Column(
                          mainAxisSize: MainAxisSize.min,
                          crossAxisAlignment: CrossAxisAlignment.stretch,
                          children: [
                            Row(
                              children: [
                                const Text('Apariencia', style: TextStyle(fontWeight: FontWeight.w700)),
                                const Spacer(),
                                IconButton(
                                  tooltip: widget.isLight ? 'Cambiar a oscuro' : 'Cambiar a claro',
                                  onPressed: () { widget.onToggleTheme(); Navigator.pop(ctx); },
                                  icon: Icon(widget.isLight ? Icons.dark_mode : Icons.light_mode),
                                ),
                              ],
                            ),
                            const SizedBox(height: 8),
                            SwitchListTile(
                              contentPadding: EdgeInsets.zero,
                              title: const Text('Rayado alterno de filas'),
                              value: zebra,
                              onChanged: (v) => setState(() => zebra = v),
                            ),
                            SwitchListTile(
                              contentPadding: EdgeInsets.zero,
                              title: const Text('Líneas de grilla'),
                              value: showGridLines,
                              onChanged: (v) => setState(() => showGridLines = v),
                            ),
                          ],
                        ),
                      );
                    },
                  );
                },
                icon: const Icon(Icons.tune),
              ),
              IconButton(
                tooltip: 'Tema',
                onPressed: widget.onToggleTheme,
                icon: Icon(widget.isLight ? Icons.dark_mode : Icons.light_mode),
              ),
              const SizedBox(width: 8),
              IconButton(
                tooltip: 'Agregar fila (Ctrl+N)',
                onPressed: () { ctrl.addRow(); _syncFromModel(); setState(() {}); },
                icon: const Icon(Icons.add),
              ),
              IconButton(
                tooltip: 'Limpiar (Ctrl+L)',
                onPressed: () { ctrl.clearAll(); _rebuildAllControllers(); },
                icon: const Icon(Icons.delete_sweep),
              ),
              IconButton(
                tooltip: 'Backup JSON (Ctrl+B)',
                onPressed: _backupDownload,
                icon: const Icon(Icons.download),
              ),
              IconButton(
                tooltip: 'Importar JSON (Ctrl+U)',
                onPressed: _backupImport,
                icon: const Icon(Icons.upload_file),
              ),
              IconButton(
                tooltip: 'Exportar XLSX (Ctrl+E)',
                onPressed: () => _exportXlsxImpl(ctrl.headers, ctrl.rows),
                icon: const Icon(Icons.file_download),
              ),
            ],
          ),
          body: SafeArea(
            child: Center(
              child: ConstrainedBox(
                constraints: const BoxConstraints(maxWidth: 1200),
                child: Padding(
                  padding: const EdgeInsets.all(16),
                  child: _grid(),
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class _AddRowIntent extends Intent { const _AddRowIntent(); }
class _ExportIntent extends Intent { const _ExportIntent(); }
class _BackupIntent extends Intent { const _BackupIntent(); }
class _ImportIntent extends Intent { const _ImportIntent(); }
class _ClearIntent extends Intent { const _ClearIntent(); }
class _DeleteRowIntent extends Intent { const _DeleteRowIntent(); }

// --- Util ---
class Debouncer {
  Debouncer(this.duration);
  final Duration duration;
  Timer? _t;
  void call(void Function() action) { _t?.cancel(); _t = Timer(duration, action); }
  void dispose() => _t?.cancel();
}













Future<void> _exportXlsxImpl(List<String> headers, List<List<dynamic>> rows) async {
  final book = xcel.Excel.createExcel();
  final sheet = book['Bitacora'];

  sheet.appendRow(<xcel.CellValue?>[
    xcel.TextCellValue('#'),
    ...headers.map((h) => xcel.TextCellValue(h)),
  ]);

  for (var r = 0; r < rows.length; r++) {
    final data = rows[r];
    sheet.appendRow(<xcel.CellValue?>[
      xcel.TextCellValue('${r + 1}'),
      ...data.map((v) => xcel.TextCellValue(v?.toString() ?? '')),
    ]);
  }

  final bytes = book.encode()!;
  await FileSaver.instance.saveFile(
    name: 'bitacora',
    ext: 'xlsx',
    mimeType: MimeType.microsoftExcel,
    bytes: Uint8List.fromList(bytes),
  );
}


