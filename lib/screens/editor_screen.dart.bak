// ignore_for_file: depend_on_referenced_packages
import 'dart:math' as math;
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../models/table_state.dart';
import '../services/local_store.dart';
import '../services/export_xlsx_service.dart';
import '../services/sheet_store.dart';
import '../utils/debouncer.dart';
import '../utils/history.dart';
import '../workers/json_worker.dart';

class EditorScreen extends StatefulWidget {
  const EditorScreen({
    super.key,
    required this.isLight,
    required this.onToggleTheme,
    required this.sheetId,
  });
  final bool isLight;
  final VoidCallback onToggleTheme;
  final String sheetId;

  @override
  State<EditorScreen> createState() => _EditorScreenState();
}

class _EditorScreenState extends State<EditorScreen> {
  static const double _indexColW = 56;
  static const double _minColW = 80;
  static const double _maxColW = 600;
  static const double _rowH = 38;
  static const double _hdrH = 42;

  late TableState _state;
  bool _loading = true;
  (int r, int c) _focus = (0, 0);
  bool _isEditing = false;

  final TextEditingController _cellEC = TextEditingController();
  final FocusNode _cellFN = FocusNode();
  final FocusNode _gridFN = FocusNode();

  final Map<int, TextEditingController> _hdrCtl = {};
  late List<double> colWidths;
  List<double> _prefix = [];
  int _firstCol = 0;
  int _lastCol = 0;
  static const int _bufferCols = 2;
  double _lastViewportW = 0;

  final _vScrollLeft = ScrollController();
  final _vScrollRight = ScrollController();
  final _hScroll = ScrollController();
  bool _syncingV = false;

  final _history = History<TableState>(cap: 200);
  final Debouncer _sheetDebounce = Debouncer(const Duration(milliseconds: 300));

  JsonWorker? _worker;

  int get _rowCount => _state.rows.length;
  int get _colCount => _state.headers.length;

  @override
  void initState() {
    super.initState();
    _state = TableState(
      headers: List<String>.filled(5, ''),
      rows: List.generate(3, (_) => List<String>.filled(5, '')),
      savedAt: DateTime.now(),
    );
    colWidths = List<double>.filled(_colCount, 180);
    _rebuildPrefix();

    _vScrollLeft.addListener(_syncFromLeft);
    _vScrollRight.addListener(_syncFromRight);
    _hScroll.addListener(_onHScroll);

    _hydrateFromStorage();
  }

  Future<void> _hydrateFromStorage() async {
    final raw = SheetStore.loadRaw(widget.sheetId);
    if (raw == null) {
      if (!mounted) return;
      setState(() => _loading = false);
      return;
    }
    _worker = JsonWorker(
      onMeta: (headers, total) {
        if (!mounted) return;
        setState(() {
          _state = TableState(headers: headers, rows: [], savedAt: DateTime.now());
          colWidths = List<double>.filled(_state.headers.length, 180);
          _rebuildPrefix();
        });
      },
      onRowsChunk: (chunk, done) {
        if (!mounted) return;
        setState(() {
          _state.rows.addAll(chunk);
          if (_loading && _state.rows.isNotEmpty) _loading = false;
        });
        if (done) {
          _sheetDebounce(() => SheetStore.saveState(widget.sheetId, _state));
        }
      },
      onError: (_) {
        // Fallback (bloqueante) solo si falla el Worker
        try {
          final ts = TableState.fromJsonString(raw);
          if (!mounted) return;
          setState(() {
            _state = ts;
            colWidths = List<double>.filled(_state.headers.length, 180);
            _rebuildPrefix();
            _loading = false;
          });
        } catch (_) { if (mounted) setState(() => _loading = false); }
      },
    )..start(raw);
  }

  @override
  void dispose() {
    _worker?.dispose();
    _cellEC.dispose();
    _cellFN.dispose();
    _gridFN.dispose();
    for (final c in _hdrCtl.values) { c.dispose(); }
    _vScrollLeft.removeListener(_syncFromLeft);
    _vScrollRight.removeListener(_syncFromRight);
    _hScroll.removeListener(_onHScroll);
    _vScrollLeft.dispose(); _vScrollRight.dispose(); _hScroll.dispose();
    _sheetDebounce.dispose();
    super.dispose();
  }

  void _resetHeaderControllers() {
    for (final c in _hdrCtl.values) { c.dispose(); }
    _hdrCtl.clear();
  }
  TextEditingController _getHdrCtl(int col) {
    final existing = _hdrCtl[col];
    if (existing != null) return existing;
    final ctl = TextEditingController(text: _state.headers[col]);
    ctl.addListener(() {
      final newHeaders = List<String>.from(_state.headers)..[col] = ctl.text;
      _updateState(TableState(headers: newHeaders, rows: _state.rows, savedAt: DateTime.now()), snapshot: false);
    });
    _hdrCtl[col] = ctl;
    return ctl;
  }

  void _rebuildPrefix() {
    _prefix = List<double>.filled(_colCount + 1, 0);
    for (int i = 0; i < _colCount; i++) { _prefix[i + 1] = _prefix[i] + colWidths[i]; }
  }
  int _lowerBound(double x) {
    int lo = 0, hi = _prefix.length;
    while (lo < hi) {
      final mid = (lo + hi) >> 1;
      if (_prefix[mid] < x) { lo = mid + 1; } else { hi = mid; }
    }
    return lo;
  }
  void _recomputeVisibleCols([double? viewportW]) {
    if (!mounted) return;
    final vw = viewportW ?? (_hScroll.hasClients ? _hScroll.position.viewportDimension : _lastViewportW);
    if (vw <= 0) return;
    final scrollX = _hScroll.hasClients ? _hScroll.offset : 0.0;
    int start = _lowerBound(scrollX) - 1; if (start < 0) start = 0;
    final endLimit = scrollX + vw;
    int end = _lowerBound(endLimit); if (end > _colCount) end = _colCount;
    start = (start - _bufferCols).clamp(0, _colCount - 1);
    end = (end + _bufferCols).clamp(0, _colCount);
    if (start > end) { start = 0; end = math.min(_colCount, 1); }
    if (start != _firstCol || end - 1 != _lastCol || vw != _lastViewportW) {
      setState(() { _firstCol = start; _lastCol = end - 1; _lastViewportW = vw; });
    }
  }
  void _onHScroll() => _recomputeVisibleCols();

  void _syncFromLeft() {
    if (_syncingV || !_vScrollRight.hasClients) return;
    final want = _vScrollLeft.offset;
    if ((_vScrollRight.offset - want).abs() < 0.5) return;
    _syncingV = true; _vScrollRight.jumpTo(want); _syncingV = false;
  }
  void _syncFromRight() {
    if (_syncingV || !_vScrollLeft.hasClients) return;
    final want = _vScrollRight.offset;
    if ((_vScrollLeft.offset - want).abs() < 0.5) return;
    _syncingV = true; _vScrollLeft.jumpTo(want); _syncingV = false;
  }

  void _updateState(TableState newState, {bool snapshot = true}) {
    final prevCols = _colCount;
    setState(() => _state = newState);
    if (snapshot) _history.push(_state);
    _sheetDebounce(() { LocalStore.save(newState); SheetStore.saveState(widget.sheetId, newState); });
    if (newState.headers.length != prevCols) {
      _resetHeaderControllers();
      colWidths = List<double>.filled(newState.headers.length, 180);
      _rebuildPrefix();
      WidgetsBinding.instance.addPostFrameCallback((_) => _recomputeVisibleCols());
    }
  }

  void _setFocus(int r, int c) {
    r = r.clamp(0, _rowCount - 1); c = c.clamp(0, _colCount - 1);
    final next = (r, c);
    if (_isEditing) { _commitCell(_focus., _focus., _cellEC.text); }
    if (_focus == next && !_isEditing) return;
    setState(() { _focus = next; _isEditing = false; });
    _ensureVisible(r, c);
  }
  void _startEditing(int r, int c) {
    _setFocus(r, c);
    if (_isEditing) return;
    _cellEC.text = _state.rows[r][c];
    setState(() => _isEditing = true);
    _cellFN.requestFocus();
    _cellEC.selection = TextSelection(baseOffset: 0, extentOffset: _cellEC.text.length);
  }
  void _commitCell(int r, int c, String newValue) {
    if (!_isEditing) return;
    setState(() => _isEditing = false);
    if (_state.rows[r][c] == newValue) return;
    final newRows = _state.rows.map((row) => List<String>.from(row)).toList();
    newRows[r][c] = newValue;
    _updateState(TableState(headers: _state.headers, rows: newRows, savedAt: DateTime.now()));
  }

  void _newRow() {
    final newRows = [..._state.rows, List<String>.filled(_colCount, '')];
    _updateState(TableState(headers: _state.headers, rows: newRows, savedAt: DateTime.now()));
  }
  void _deleteFocusedRow() {
    if (_rowCount <= 1) return;
    final r = _focus..clamp(0, _rowCount - 1);
    final newRows = _state.rows.map((row) => List<String>.from(row)).toList();
    newRows.removeAt(r);
    _updateState(TableState(headers: _state.headers, rows: newRows, savedAt: DateTime.now()));
    _setFocus((r - 1).clamp(0, _rowCount - 1), _focus.);
  }
  void _clearAll() {
    _updateState(TableState(
      headers: List<String>.from(_state.headers),
      rows: List.generate(3, (_) => List<String>.filled(_colCount, '')),
      savedAt: DateTime.now(),
    ));
    _resetHeaderControllers();
  }
  void _undo() { final s = _history.undo(); if (s != null) { _updateState(s, snapshot: false); _resetHeaderControllers(); } }
  void _redo() { final s = _history.redo(); if (s != null) { _updateState(s, snapshot: false); _resetHeaderControllers(); } }

  Future<void> _exportXlsx() => ExportXlsxService.download(
    fileName: 'bitacora.xlsx', headers: _state.headers, rows: _state.rows);

  Future<void> _backupDownload() async => LocalStore.downloadBackup(_state);
  Future<void> _backupImport() async {
    final ts = await LocalStore.importBackup(); if (ts == null) return;
    final rows = ts.rows.isEmpty ? List.generate(3, (_) => List<String>.filled(ts.headers.length, '')) : ts.rows;
    _updateState(TableState(headers: ts.headers, rows: rows, savedAt: DateTime.now()));
    _resetHeaderControllers(); _rebuildPrefix();
    WidgetsBinding.instance.addPostFrameCallback((_) => _recomputeVisibleCols());
  }

  KeyEventResult _handleGridKey(FocusNode _, KeyEvent e) {
    if (e is! KeyDownEvent) return KeyEventResult.ignored;
    if (_isEditing) return KeyEventResult.ignored;
    final (r, c) = _focus;
    if (e.logicalKey == LogicalKeyboardKey.arrowDown) { _setFocus(r + 1, c); return KeyEventResult.handled; }
    if (e.logicalKey == LogicalKeyboardKey.arrowUp) { _setFocus(r - 1, c); return KeyEventResult.handled; }
    if (e.logicalKey == LogicalKeyboardKey.arrowRight) { _setFocus(r, c + 1); return KeyEventResult.handled; }
    if (e.logicalKey == LogicalKeyboardKey.arrowLeft) { _setFocus(r, c - 1); return KeyEventResult.handled; }
    if (e.logicalKey == LogicalKeyboardKey.tab) { _setFocus(r, c + (_shiftDown() ? -1 : 1)); return KeyEventResult.handled; }
    if (e.logicalKey == LogicalKeyboardKey.enter || e.logicalKey == LogicalKeyboardKey.numpadEnter) {
      _startEditing(r, c); return KeyEventResult.handled;
    }
    if (_isPrintable(e)) {
      _startEditing(r, c); _cellEC.text = e.character ?? '';
      _cellEC.selection = const TextSelection.collapsed(offset: 1);
      return KeyEventResult.handled;
    }
    return KeyEventResult.ignored;
  }
  KeyEventResult _handleCellKey(FocusNode _, KeyEvent e) {
    if (e is! KeyDownEvent) return KeyEventResult.ignored;
    if (e.logicalKey == LogicalKeyboardKey.enter || e.logicalKey == LogicalKeyboardKey.numpadEnter) {
      _setFocus(_focus. + (_shiftDown() ? -1 : 1), _focus.); return KeyEventResult.handled;
    }
    if (e.logicalKey == LogicalKeyboardKey.tab) {
      _setFocus(_focus., _focus. + (_shiftDown() ? -1 : 1)); return KeyEventResult.handled;
    }
    if (e.logicalKey == LogicalKeyboardKey.escape) { setState(() => _isEditing = false); _gridFN.requestFocus(); return KeyEventResult.handled; }
    return KeyEventResult.ignored;
  }
  bool _shiftDown() {
    final keys = HardwareKeyboard.instance.logicalKeysPressed;
    return keys.contains(LogicalKeyboardKey.shiftLeft) || keys.contains(LogicalKeyboardKey.shiftRight);
  }
  bool _isPrintable(KeyEvent e) {
    if (e is! KeyDownEvent) return false;
    final ch = e.character; if (ch == null || ch.isEmpty) return false;
    const non = <LogicalKeyboardKey>{
      LogicalKeyboardKey.enter, LogicalKeyboardKey.tab, LogicalKeyboardKey.escape,
      LogicalKeyboardKey.arrowDown, LogicalKeyboardKey.arrowUp, LogicalKeyboardKey.arrowLeft, LogicalKeyboardKey.arrowRight
    };
    return !non.contains(e.logicalKey) && ch.runes.length == 1;
  }

  void _ensureVisible(int r, int c) {
    if (_vScrollRight.hasClients) {
      final targetTop = r * _rowH;
      final targetBottom = targetTop + _rowH;
      final viewTop = _vScrollRight.offset;
      final viewBottom = viewTop + _vScrollRight.position.viewportDimension;
      if (targetTop < viewTop) {
        _vScrollRight.animateTo(targetTop, duration: const Duration(milliseconds: 120), curve: Curves.easeOut);
      } else if (targetBottom > viewBottom) {
        _vScrollRight.animateTo(targetBottom - _vScrollRight.position.viewportDimension,
          duration: const Duration(milliseconds: 120), curve: Curves.easeOut);
      }
    }
    if (_hScroll.hasClients) {
      final x = _prefix[c];
      final cellW = colWidths[c];
      final viewX = _hScroll.offset;
      final viewW = _hScroll.position.viewportDimension;
      if (x < viewX) {
        _hScroll.animateTo(x, duration: const Duration(milliseconds: 120), curve: Curves.easeOut);
      } else if (x + cellW > viewX + viewW) {
        _hScroll.animateTo(x + cellW - viewW, duration: const Duration(milliseconds: 120), curve: Curves.easeOut);
      }
    }
  }

  double _measureText(String text, TextStyle style) {
    final tp = TextPainter(text: TextSpan(text: text, style: style), textDirection: TextDirection.ltr, maxLines: 1)
      ..layout(minWidth: 0, maxWidth: double.infinity);
    return tp.width;
  }
  void _autoFitColumn(int c) {
    final cellStyle = Theme.of(context).textTheme.bodyMedium ?? const TextStyle();
    const hdrStyle = TextStyle(fontWeight: FontWeight.w700);
    double maxW = 0;
    final hdrText = _state.headers[c].isEmpty ? 'Col \' : _state.headers[c];
    maxW = math.max(maxW, _measureText(hdrText, hdrStyle));
    for (final row in _state.rows) {
      maxW = math.max(maxW, _measureText(row[c], cellStyle));
    }
    final target = (maxW + 24).clamp(_minColW, _maxColW).toDouble();
    setState(() { colWidths[c] = target; _rebuildPrefix(); });
    WidgetsBinding.instance.addPostFrameCallback((_) => _recomputeVisibleCols());
  }

  @override
  Widget build(BuildContext context) {
    return FocusTraversalGroup(
      policy: WidgetOrderTraversalPolicy(),
      child: Shortcuts(
        shortcuts: const <LogicalKeySet, Intent>{
          LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyN): _NewRowIntent(),
          LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyZ): _UndoIntent(),
          LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyY): _RedoIntent(),
          LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyL): _ClearAllIntent(),
          LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyD): _DeleteRowIntent(),
          LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyE): _ExportIntent(),
          LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyB): _BackupIntent(),
          LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyU): _ImportIntent(),
        },
        child: Actions(
          actions: <Type, Action<Intent>>{
            _NewRowIntent: CallbackAction<_NewRowIntent>(onInvoke: (_) { _newRow(); return null; }),
            _UndoIntent: CallbackAction<_UndoIntent>(onInvoke: (_) { _undo(); return null; }),
            _RedoIntent: CallbackAction<_RedoIntent>(onInvoke: (_) { _redo(); return null; }),
            _ClearAllIntent: CallbackAction<_ClearAllIntent>(onInvoke: (_) { _clearAll(); return null; }),
            _DeleteRowIntent: CallbackAction<_DeleteRowIntent>(onInvoke: (_) { _deleteFocusedRow(); return null; }),
            _ExportIntent: CallbackAction<_ExportIntent>(onInvoke: (_) { _exportXlsx(); return null; }),
            _BackupIntent: CallbackAction<_BackupIntent>(onInvoke: (_) { _backupDownload(); return null; }),
            _ImportIntent: CallbackAction<_ImportIntent>(onInvoke: (_) { _backupImport(); return null; }),
          },
          child: Scaffold(
            appBar: AppBar(
              leading: IconButton(tooltip: 'Inicio', onPressed: () => Navigator.pop(context), icon: const Icon(Icons.arrow_back)),
              title: const Text('Editor'),
              actions: [
                IconButton(
                  tooltip: Theme.of(context).brightness == Brightness.light ? 'Cambiar a oscuro' : 'Cambiar a claro',
                  onPressed: widget.onToggleTheme,
                  icon: Icon(Theme.of(context).brightness == Brightness.light ? Icons.dark_mode : Icons.light_mode),
                ),
                IconButton(tooltip: 'Deshacer (Ctrl+Z)', onPressed: _undo, icon: const Icon(Icons.undo)),
                IconButton(tooltip: 'Rehacer (Ctrl+Y)', onPressed: _redo, icon: const Icon(Icons.redo)),
                IconButton(tooltip: 'Backup JSON (Ctrl+B)', onPressed: _backupDownload, icon: const Icon(Icons.download)),
                IconButton(tooltip: 'Importar JSON (Ctrl+U)', onPressed: _backupImport, icon: const Icon(Icons.upload_file)),
                IconButton(tooltip: 'Exportar XLSX (Ctrl+E)', onPressed: _exportXlsx, icon: const Icon(Icons.table_view)),
              ],
            ),
            body: SafeArea(
              child: _loading
                  ? const _EditorSkeleton()
                  : Column(
                      children: [
                        _buildHeaderRow(),
                        const Divider(height: 1, thickness: 0),
                        Expanded(child: _buildGridBody()),
                      ],
                    ),
            ),
            floatingActionButton: _loading ? null : FloatingActionButton.extended(
              onPressed: _newRow, label: const Text('Fila'), icon: const Icon(Icons.add)),
          ),
        ),
      ),
    );
  }

  Widget _buildHeaderRow() {
    final bg = Theme.of(context).brightness == Brightness.light ? const Color(0xFFF9F9FB) : const Color(0xFF111827);
    return Container(
      height: _hdrH,
      color: bg.withValues(alpha: 0.92),
      child: Row(
        children: [
          _buildIndexHeader(),
          Expanded(
            child: LayoutBuilder(
              builder: (_, cons) {
                final vw = cons.maxWidth; if (vw > 0) _recomputeVisibleCols(vw);
                return SingleChildScrollView(
                  controller: _hScroll, scrollDirection: Axis.horizontal,
                  child: SizedBox(
                    width: _prefix.isEmpty ? 0 : _prefix.last,
                    height: _hdrH,
                    child: Row(
                      children: [
                        SizedBox(width: _sumRange(0, _firstCol)),
                        for (int c = _firstCol; c <= _lastCol; c++) _buildHeaderCell(c),
                        SizedBox(width: _sumRange(_lastCol + 1, _colCount)),
                      ],
                    ),
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
  Widget _buildIndexHeader() {
    return Container(
      width: _indexColW, height: _hdrH, alignment: Alignment.center,
      decoration: BoxDecoration(border: Border(
        bottom: BorderSide(color: Theme.of(context).dividerColor),
        right: BorderSide(color: Theme.of(context).dividerColor),
      )),
      child: const Text('#', style: TextStyle(fontWeight: FontWeight.w700)),
    );
  }
  Widget _buildHeaderCell(int c) {
    final titleColor = Theme.of(context).textTheme.titleMedium?.color;
    final hintColor = titleColor?.withValues(alpha: 0.55);
    final bg = Theme.of(context).brightness == Brightness.light ? const Color(0xFFF9F9FB) : const Color(0xFF111827);
    final w = colWidths[c];
    final ctl = _getHdrCtl(c);
    return SizedBox(
      width: w, height: _hdrH,
      child: Stack(
        children: [
          Positioned.fill(
            right: 10,
            child: Container(
              alignment: Alignment.centerLeft,
              padding: const EdgeInsets.symmetric(horizontal: 12),
              decoration: BoxDecoration(
                color: bg.withValues(alpha: 0.92),
                border: Border(
                  bottom: BorderSide(color: Theme.of(context).dividerColor),
                  right: BorderSide(color: Theme.of(context).dividerColor),
                ),
              ),
              child: TextField(
                controller: ctl,
                maxLines: 1,
                textInputAction: TextInputAction.next,
                decoration: InputDecoration(
                  isDense: true,
                  border: InputBorder.none,
                  hintText: 'Col \',
                  hintStyle: TextStyle(fontWeight: FontWeight.w600, color: hintColor),
                ),
                style: const TextStyle(fontWeight: FontWeight.w700),
                onSubmitted: (_) { _setFocus(0, c); _gridFN.requestFocus(); },
              ),
            ),
          ),
          Positioned(
            right: 0, top: 0, bottom: 0,
            child: SizedBox(
              width: 10,
              child: MouseRegion(
                cursor: SystemMouseCursors.resizeLeftRight,
                child: GestureDetector(
                  behavior: HitTestBehavior.opaque,
                  onHorizontalDragUpdate: (d) {
                    setState(() {
                      final next = (colWidths[c] + d.delta.dx).clamp(_minColW, _maxColW);
                      colWidths[c] = next.toDouble(); _rebuildPrefix();
                    });
                    WidgetsBinding.instance.addPostFrameCallback((_) => _recomputeVisibleCols());
                  },
                  onDoubleTap: () => _autoFitColumn(c),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
  double _sumRange(int a, int bExclusive) {
    if (_prefix.isEmpty) return 0;
    a = a.clamp(0, _colCount); bExclusive = bExclusive.clamp(0, _colCount);
    if (bExclusive < a) return 0;
    return _prefix[bExclusive] - _prefix[a];
  }

  Widget _buildGridBody() {
    final bgOdd = Theme.of(context).brightness == Brightness.light ? const Color(0xFFFDFDFE) : const Color(0xFF0F1522);
    return Focus(
      focusNode: _gridFN,
      onKeyEvent: _handleGridKey,
      child: Row(
        children: [
          SizedBox(
            width: _indexColW,
            child: ListView.builder(
              primary: false, controller: _vScrollLeft, itemExtent: _rowH, itemCount: _rowCount,
              itemBuilder: (context, r) {
                final selected = r == _focus.;
                final rowBg = (r.isOdd) ? bgOdd : Colors.transparent;
                return InkWell(
                  onTap: () { _setFocus(r, _focus.); _gridFN.requestFocus(); },
                  child: Container(
                    alignment: Alignment.center, color: rowBg,
                    child: Stack(fit: StackFit.expand, children: [
                      Container(
                        alignment: Alignment.center,
                        decoration: BoxDecoration(border: Border(
                          bottom: BorderSide(color: Theme.of(context).dividerColor),
                          right: BorderSide(color: Theme.of(context).dividerColor),
                        )),
                        child: Text('\', style: TextStyle(
                          fontWeight: selected ? FontWeight.w700 : FontWeight.w500,
                        )),
                      ),
                      if (selected)
                        IgnorePointer(child: Container(
                          decoration: BoxDecoration(
                            border: Border.all(color: Theme.of(context).colorScheme.primary, width: 2),
                          ),
                        )),
                    ]),
                  ),
                );
              },
            ),
          ),
          Expanded(
            child: LayoutBuilder(
              builder: (_, cons) {
                final vw = cons.maxWidth; if (vw > 0) _recomputeVisibleCols(vw);
                return SingleChildScrollView(
                  controller: _hScroll, scrollDirection: Axis.horizontal,
                  child: SizedBox(
                    width: _prefix.isEmpty ? 0 : _prefix.last,
                    child: ListView.builder(
                      primary: false, controller: _vScrollRight, itemExtent: _rowH, itemCount: _rowCount,
                      itemBuilder: (context, r) {
                        final rowBg = (r.isOdd) ? bgOdd : Colors.transparent;
                        return Container(
                          color: rowBg,
                          child: Row(
                            children: [
                              SizedBox(width: _sumRange(0, _firstCol)),
                              for (int c = _firstCol; c <= _lastCol; c++) _buildDataCell(r, c),
                              SizedBox(width: _sumRange(_lastCol + 1, _colCount)),
                            ],
                          ),
                        );
                      },
                    ),
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildDataCell(int r, int c) {
    final w = colWidths[c];
    final isFocused = _focus. == r && _focus. == c;
    final text = _state.rows[r][c];

    Widget content;
    if (_isEditing && isFocused) {
      content = Focus(
        focusNode: _cellFN, onKeyEvent: _handleCellKey,
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 8),
          child: TextField(
            controller: _cellEC, autofocus: true,
            decoration: const InputDecoration(isDense: true, border: InputBorder.none, contentPadding: EdgeInsets.zero),
            onEditingComplete: () { _commitCell(r, c, _cellEC.text); _gridFN.requestFocus(); },
          ),
        ),
      );
    } else {
      content = Padding(
        padding: const EdgeInsets.symmetric(horizontal: 10),
        child: Align(alignment: Alignment.centerLeft, child: Text(text, maxLines: 1, overflow: TextOverflow.ellipsis)),
      );
    }

    return SizedBox(
      width: w, height: _rowH,
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTap: () { _setFocus(r, c); _gridFN.requestFocus(); },
        onDoubleTap: () => _startEditing(r, c),
        child: Container(
          decoration: BoxDecoration(border: Border(
            bottom: BorderSide(color: Theme.of(context).dividerColor),
            right: BorderSide(color: Theme.of(context).dividerColor),
          )),
          child: Stack(fit: StackFit.expand, children: [
            content,
            if (isFocused && !_isEditing)
              IgnorePointer(child: Container(
                decoration: BoxDecoration(
                  border: Border.all(color: Theme.of(context).colorScheme.primary, width: 2),
                ),
              )),
          ]),
        ),
      ),
    );
  }
}

class _NewRowIntent extends Intent { const _NewRowIntent(); }
class _UndoIntent extends Intent { const _UndoIntent(); }
class _RedoIntent extends Intent { const _RedoIntent(); }
class _ClearAllIntent extends Intent { const _ClearAllIntent(); }
class _DeleteRowIntent extends Intent { const _DeleteRowIntent(); }
class _ExportIntent extends Intent { const _ExportIntent(); }
class _BackupIntent extends Intent { const _BackupIntent(); }
class _ImportIntent extends Intent { const _ImportIntent(); }

class _EditorSkeleton extends StatelessWidget {
  const _EditorSkeleton();
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        const LinearProgressIndicator(minHeight: 2),
        const Spacer(),
        Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2.6)),
            const SizedBox(width: 10),
            Text('Abriendo planilla…', style: Theme.of(context).textTheme.bodyMedium),
          ],
        ),
        const Spacer(),
      ],
    );
  }
}
